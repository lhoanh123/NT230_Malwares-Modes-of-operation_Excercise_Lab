using AsmResolver;
using AsmResolver.PE;
using AsmResolver.PE.Code;
using AsmResolver.PE.File;
using AsmResolver.PE.File.Headers;
using AsmResolver.PE.Imports;
using AsmResolver.PE.Imports.Builder;
using AsmResolver.PE.Platforms;
using AsmResolver.PE.Relocations;
using AsmResolver.PE.Relocations.Builder;

namespace AddSection;

internal static class Program
{
    public static void Main()
    {
        // Đường dẫn đến tập tin exe.
        string filePath = "D:\\VS\\ConsoleApp3\\ConsoleApp3\\popup.exe";

        // Nhập tên phần để thêm mã vào.
        Console.Write("Enter the section name: ");
        string sectionName = Console.ReadLine() ?? string.Empty;

        // Nhập mã (hệ thập lục).
        byte[] code = 
        {
            /* 00000000: */ 0x48, 0x8D, 0x0D, 0x00, 0x00, 0x00, 0x00,                   // lea rcx, [rel message]
            /* 00000007: */ 0xFF, 0x15, 0x00, 0x00, 0x00, 0x00,                         // call [rel puts]
            /* 0000000D: */ 0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, &originalEntryPoint
            /* 00000017: */ 0xFF, 0xE0,                                                 // jmp rax
            
            // message:
            /* 00000019: */ 0x4C, 0x65, 0x20, 0x48, 0x6F, 0x61, 0x6E, 0x67, 0x20, 0x4F, // "Le Hoang O"
            /* 00000023: */ 0x61, 0x6E, 0x68, 0x20, 0x2D, 0x20, 0x32, 0x31, 0x35, 0x32, // "anh - 2152"
            /* 0000002D: */ 0x31, 0x32, 0x35, 0x33, 0x00                                            // "1253".
        };

        // Đọc tập tin exe và hình ảnh PE.
        var peFile = PEFile.FromFile(filePath);
        var peImage = PEImage.FromFile(peFile);

        // Inject mã mới vào phần đã chỉ định.
        var newCodeSegment = InjectNewCode(peFile, peImage, sectionName, code);
        peFile.UpdateHeaders();
        peFile.OptionalHeader.AddressOfEntryPoint = newCodeSegment.Rva;

        // Inject các trampoline.
        InjectTrampolines(peFile, peImage);

        // Xây dựng lại bảng IAT và relocs.
        RebuildIatAndRelocs(peFile, peImage);

        // Ghi tập tin đã sửa đổi ra đường dẫn mới.
        string outputFilePath = GetOutputFilePath(filePath);
        peFile.Write(outputFilePath);
    }

    // Lấy đường dẫn đến tập tin mới.
    private static string GetOutputFilePath(string originalFilePath)
    {
        string directory = Path.GetDirectoryName(originalFilePath) ?? string.Empty;
        string fileName = Path.GetFileNameWithoutExtension(originalFilePath) ?? string.Empty;
        string extension = Path.GetExtension(originalFilePath) ?? string.Empty;
        return Path.Combine(directory, $"{fileName}.modified{extension}");
    }

    private static ISegment InjectNewCode(PEFile peFile, IPEImage peImage, string sectionName, byte[] code)
    {
        // Import hàm puts từ thư viện ucrtbase.dll vào hình ảnh PE.
        var ucrtbaseModule = new ImportedModule("ucrtbase.dll");
        var putsSymbol = new ImportedSymbol(0, "puts");
        ucrtbaseModule.Symbols.Add(putsSymbol);
        peImage.Imports.Add(ucrtbaseModule);

        // Định nghĩa một entry point symbol mà có thể tham chiếu sau này trong mã.
        var originalEntryPointSymbol = new Symbol(peFile.GetReferenceToRva(peFile.OptionalHeader.AddressOfEntryPoint));

        // Viết mã.
        var codeSegment = peImage.MachineType switch
        {
            MachineType.I386 => CreateI386CodeSegment(putsSymbol, originalEntryPointSymbol, code),
            MachineType.Amd64 => CreateAmd64CodeSegment(putsSymbol, originalEntryPointSymbol, code),
            _ => throw new NotImplementedException($"Nền tảng {peImage.MachineType} không được triển khai.")
        };

        // Thêm tất cả các mục dữ liệu có thể di chuyển vào hình ảnh PE.
        foreach (var relocation in codeSegment.Relocations)
            peImage.Relocations.Add(relocation);

        // Thêm mã thực sự vào một phần mới có thể đọc và thực thi (RX).
        peFile.Sections.Add(new PESection(
            sectionName,
            SectionFlags.MemoryRead | SectionFlags.MemoryExecute | SectionFlags.ContentCode,
            codeSegment.Segment));

        return codeSegment.Segment;
    }

    private static RelocatableSegment CreateI386CodeSegment(ISymbol putsSymbol, ISymbol originalEntryPointSymbol, byte[] code)
    {
        var codeSegment = new DataSegment(code).AsPatchedSegment()
            .Patch(relativeOffset: 0x1, AddressFixupType.Absolute32BitAddress, +0x12 /* &message */)
            .Patch(relativeOffset: 0x7, AddressFixupType.Absolute32BitAddress, putsSymbol)
            .Patch(relativeOffset: 0xC, AddressFixupType.Absolute32BitAddress, originalEntryPointSymbol);

        return new RelocatableSegment(codeSegment, new[]
        {
        new BaseRelocation(RelocationType.HighLow, codeSegment.ToReference(0x1)),
        new BaseRelocation(RelocationType.HighLow, codeSegment.ToReference(0x7)),
        new BaseRelocation(RelocationType.HighLow, codeSegment.ToReference(0xC)),
        });
    }

    private static RelocatableSegment CreateAmd64CodeSegment(ISymbol putsSymbol, ISymbol originalEntryPointSymbol, byte[] code)
    {
        var codeSegment = new DataSegment(code).AsPatchedSegment()
            .Patch(0x3, AddressFixupType.Relative32BitAddress, 0x19)
            .Patch(0x9, AddressFixupType.Relative32BitAddress, putsSymbol)
            .Patch(0xF, AddressFixupType.Absolute64BitAddress, originalEntryPointSymbol);

        return new RelocatableSegment(codeSegment, new[]
        {
        new BaseRelocation(RelocationType.Dir64, codeSegment.ToReference(0xF))
        });
    }


    private static void InjectTrampolines(PEFile peFile, IPEImage peImage)
    {
        var platform = Platform.Get(peFile.FileHeader.Machine);
        bool is64Bit = peFile.OptionalHeader.Magic == OptionalHeaderMagic.PE64;

        // Xây dựng bảng các trampoline.
        var trampolineTableBuilder = new SegmentBuilder();
        foreach (var importedModule in peImage.Imports)
        {
            foreach (var importedSymbol in importedModule.Symbols)
            {
                // Tìm địa chỉ IAT và lấy section đi kèm.
                if (importedSymbol.AddressTableEntry is null)
                    continue;

                uint iatEntryRva = importedSymbol.AddressTableEntry!.Rva;
                var section = peFile.GetSectionContainingRva(iatEntryRva);
                if (section.Contents?.AsPatchedSegment() is not { } sectionContents)
                    continue;

                // Xây dựng trampoline stub và làm cho nó có thể relocate.
                var trampolineStub = platform.CreateThunkStub(importedSymbol);
                var trampolineSymbol = new Symbol(trampolineStub.Segment.ToReference());

                trampolineTableBuilder.Add(trampolineStub.Segment);
                foreach (var relocation in trampolineStub.Relocations)
                    peImage.Relocations.Add(relocation);

                // Patch IAT gốc với địa chỉ của trampoline stub, và làm cho nó có thể relocate.
                sectionContents.Patch(
                    iatEntryRva - sectionContents.Rva,
                    AddressFixupType.Absolute64BitAddress,
                    trampolineSymbol);

                peImage.Relocations.Add(new BaseRelocation(
                    is64Bit ? RelocationType.Dir64 : RelocationType.HighLow,
                    importedSymbol.AddressTableEntry));

                // Cập nhật nội dung của section.
                section.Contents = sectionContents;
            }
        }

        // Thêm các trampoline stub vào một section mới có thể đọc và thực thi.
        peFile.Sections.Add(new PESection(
            ".trmpln",
            SectionFlags.ContentCode | SectionFlags.MemoryRead | SectionFlags.MemoryExecute,
            trampolineTableBuilder));
    }

    private static void RebuildIatAndRelocs(PEFile peFile, IPEImage peImage)
    {
        // Tạo lại thư mục nhập.
        var importDirectoryBuffer = new ImportDirectoryBuffer(peImage.MachineType != MachineType.Amd64);
        foreach (var importedModule in peImage.Imports)
            importDirectoryBuffer.AddModule(importedModule);

        peFile.Sections.Add(new PESection(
            ".idata2",
            SectionFlags.ContentCode | SectionFlags.ContentUninitializedData | SectionFlags.MemoryRead,
            new SegmentBuilder
            {
            { importDirectoryBuffer, 8 },
            { importDirectoryBuffer.ImportAddressDirectory, 8 },
            }));

        // Tạo lại thư mục relocation.
        var relocationsDirectoryBuffer = new RelocationsDirectoryBuffer();
        foreach (var relocation in peImage.Relocations)
            relocationsDirectoryBuffer.Add(relocation);

        peFile.Sections.Add(new PESection(
            ".reloc2",
            SectionFlags.ContentInitializedData | SectionFlags.MemoryRead | SectionFlags.MemoryDiscardable,
            relocationsDirectoryBuffer
        ));

        // Tính toán lại offsets và cập nhật headers, kết nối lại các bảng IDT, IAT và reloc cũ với các bảng mới.
        peFile.UpdateHeaders();

        var dataDirectories = peFile.OptionalHeader.DataDirectories;
        dataDirectories[(int)DataDirectoryIndex.BaseRelocationDirectory] = new(
            relocationsDirectoryBuffer.Rva,
            relocationsDirectoryBuffer.GetVirtualSize());

        dataDirectories[(int)DataDirectoryIndex.ImportDirectory] = new(
            importDirectoryBuffer.Rva,
            importDirectoryBuffer.GetVirtualSize());

        dataDirectories[(int)DataDirectoryIndex.IatDirectory] = new(
            importDirectoryBuffer.ImportAddressDirectory.Rva,
            importDirectoryBuffer.ImportAddressDirectory.GetVirtualSize());
    }
}